# 2. 创建第一个子系统

在本教程中，我们将学习如何创建一个完整的机器人子系统。我们将参考`Chassis`子系统的结构，创建一个新的`Intake`子系统。`Intake`子系统通常用于收集游戏物品，如球体或立方体。

WPILib的子系统设计遵循几个关键的设计原则，这些原则共同确保了代码的健壮性、可维护性和可测试性。首先，系统采用**依赖注入模式**，通过专门的工厂方法在不同环境中创建相应的实例，这使得在真实机器人、模拟器和测试平台之间的切换变得无缝且自然。其次，**接口隔离原则**得到了充分应用，通过硬件抽象层将业务逻辑与具体的硬件实现解耦，子系统只依赖于抽象的硬件接口而非具体的电机或传感器类，大大提高了代码的灵活性。

此外，**配置集中管理**是另一个核心原则，所有硬件参数、PID常数、机械特性等都在统一的配置类中进行管理，这不仅使得参数调整更加方便，也保证了整个系统中配置信息的一致性。最后，**状态监测机制**被深度集成，子系统会实时监控硬件的连接状态、运行数据，并通过警报系统及时通知操作人员任何异常情况，为机器人的稳定运行提供了有力保障。这些原则共同构建了一个既强大又易于维护的机器人软件架构。

## 示例程序

让我们以底盘子系统为例，分析组成一个子系统的关键结构：

::: code-group

```java [Chassis.java]
public class Chassis extends SubsystemBase {
  // a. 硬件接口
  // b. 核心方法
  // c. 静态初始化块
  // d. 周期性方法
  // e. 构造方法和工厂方法
}
```

```java [ChassisConfig.java]
public class ChassisConfig {
  // f. 配置参数
}
```

:::

### a. 硬件接口

```java
public class Chassis extends SubsystemBase {
  private final GenericWheelIO leftIO;
  private final GenericWheelIO rightIO;
  private final GenericWheelIOInputsAutoLogged leftInputs = new GenericWheelIOInputsAutoLogged();
  private final GenericWheelIOInputsAutoLogged rightInputs = new GenericWheelIOInputsAutoLogged();
  private final Alert leftOfflineAlert = new Alert("Chassis Left Offline", Alert.AlertType.WARNING);
  private final Alert rightOfflineAlert = new Alert("Chassis Right Offline", Alert.AlertType.WARNING);
}
```

这里使用`GenericWheelIO`接口而不是具体的电机类，这样可以在真实机器人、模拟器和测试环境中无缝切换。`~InputsAutoLogged`用于自动记录数据到AdvantageKit。

### b. 核心方法

```java
public class Chassis extends SubsystemBase {
  public void setWheelsVelocities(double leftVelocity, double rightVelocity) {
    leftIO.setVelocity(leftVelocity / ChassisConfig.WHEEL_RADIUS_METER, 0.0);
    rightIO.setVelocity(rightVelocity / ChassisConfig.WHEEL_RADIUS_METER, 0.0);
  }
}
```

公共方法应该以有意义的单位（如米/秒）接受参数，在内部转换为电机需要的单位（如弧度/秒）。

### c. 静态初始化块

```java
public class Chassis extends SubsystemBase {
  static {
    final var driveGains = ChassisConfig.getDriveGains();
    ChassisConfig.driveKp.initDefault(driveGains.kp());
    ChassisConfig.driveKd.initDefault(driveGains.kd());
    ChassisConfig.driveKs.initDefault(driveGains.ks());
  }
}
```

静态块在类加载时执行，用于根据运行模式设置不同的默认PID参数。

### d. 周期性方法

```java
public class Chassis extends SubsystemBase {
  @Override
  public void periodic() {
    // 1. 更新硬件输入
    leftIO.updateInputs(leftInputs);
    rightIO.updateInputs(rightInputs);

    // 2. 记录数据
    Logger.processInputs("Chassis Left", leftInputs);
    Logger.processInputs("Chassis Right", rightInputs);

    // 3. 状态监测和警报
    leftOfflineAlert.set(!leftInputs.connected);
    rightOfflineAlert.set(!rightInputs.connected);

    // 4. 动态参数更新
    LoggedTunableNumber.ifChanged(
        hashCode(),
        () -> {
          leftIO.setPdf(
              ChassisConfig.driveKp.get(),
              ChassisConfig.driveKd.get(),
              ChassisConfig.driveKs.get());
          rightIO.setPdf(
              ChassisConfig.driveKp.get(),
              ChassisConfig.driveKd.get(),
              ChassisConfig.driveKs.get());
        },
        ChassisConfig.driveKp,
        ChassisConfig.driveKd,
        ChassisConfig.driveKs);

    // 5. 里程计更新
    // Simplify for tank drive odometry
    RobotContainer.getOdometry()
        .addWheeledObservation(
            new WheeledObservation(
                Timer.getFPGATimestamp(),
                new DifferentialDriveWheelPositions(
                    leftInputs.positionRad * ChassisConfig.WHEEL_RADIUS_METER,
                    rightInputs.positionRad * ChassisConfig.WHEEL_RADIUS_METER),
                null));
  }
}
```

周期性方法按固定频率执行，负责读取硬件状态、记录关键数据、监测故障、动态更新可调参数和处理其他子系统的特殊逻辑。

### e. 构造方法和工厂方法

```java
public class Chassis extends SubsystemBase {
  private Chassis(GenericWheelIO leftIO, GenericWheelIO rightIO) {
    this.leftIO = leftIO;
    this.rightIO = rightIO;
  }

  // 真实实例 - 使用Kraken电机
  public static Chassis createReal() {
    return new Chassis(
        new GenericWheelIOKraken(
                "Left Drive",
                Constants.Ports.Can.LEFT_DRIVE_MASTER,
                ChassisConfig.getDriveConfig())
            .withFollower(Constants.Ports.Can.LEFT_DRIVE_SLAVE, true),
        new GenericWheelIOKraken(
                "Right Drive",
                Constants.Ports.Can.RIGHT_DRIVE_MASTER,
                ChassisConfig.getDriveConfig())
            .withFollower(Constants.Ports.Can.RIGHT_DRIVE_SLAVE, true));
  }

  // 模拟实例 - 使用模拟电机
  public static Chassis createSim() {
    return new Chassis(
        new GenericWheelIOSim(
            2,
            0.025,
            ChassisConfig.DRIVE_REDUCTION,
            ChassisConfig.driveKp.get(),
            ChassisConfig.driveKd.get()),
        new GenericWheelIOSim(
            2,
            0.025,
            ChassisConfig.DRIVE_REDUCTION,
            ChassisConfig.driveKp.get(),
            ChassisConfig.driveKd.get()));
  }

  // IO测试实例 - 空实现
  public static Chassis createIO() {
    return new Chassis(new GenericWheelIO() {}, new GenericWheelIO() {});
  }
}
```

工厂模式让创建逻辑与使用逻辑分离，使得在不同环境间切换变得简单。

### f. 配置参数

```java
public class ChassisConfig {
  // 可调参数
  static final LoggedTunableNumber driveKp = new LoggedTunableNumber(DebugGroup.CHASSIS, "DriveKp");
  static final LoggedTunableNumber driveKd = new LoggedTunableNumber(DebugGroup.CHASSIS, "DriveKd");
  static final LoggedTunableNumber driveKs = new LoggedTunableNumber(DebugGroup.CHASSIS, "DriveKs");

  // 根据运行模式返回不同的增益参数
  static Gains getDriveGains() {
    return switch (Constants.MODE) {
      case REAL -> new Gains(10.0, 0.1, 0.2);
      case SIM, REPLAY -> new Gains(0.25, 0.0, 0.0);
    };
  }

  // 机械常数
  static final double DRIVE_REDUCTION = 10.71; // 10.71:1
  public static final double TRACK_WIDTH = 0.69; // meters
  static final double WHEEL_RADIUS_METER = 0.0479;

  // 电机配置
  static TalonFXConfiguration getDriveConfig() {
    var config = new TalonFXConfiguration();
    // ...
    return config;
  }

  record Gains(double kp, double kd, double ks) {}
}
```

配置类集中管理所有参数，包括可在Dashbord中实时调整的可调参数、机械常数以及不同环境的特定配置。

## 你的回合

现在你需要参考`Chassis`的结构，完成`Intake`子系统的设计。必须实现的核心方法已经给出，你可以根据它来完成你的代码设计。

## 效果演示

<div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%;">
  <iframe src="/ddocc/2/demo.mp4" frameborder="0" allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe>
</div>
