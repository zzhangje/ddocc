# 3. Create a Primitive Command

In this tutorial, we will learn how to create robot commands. Commands are the basic units for implementing robot behavior in WPILib, encapsulating specific actions or behavior sequences. We will reference the structure of the `ChassisTeleop` command to create a new `IntakeTeleop` command. [Code download link](https://github.com/zzhangje/ddocc/archive/refs/heads/v0.3.zip)

WPILib's command framework is based on the command pattern design and has the following key characteristics:

- **Composability**: Commands can be composed into more complex behavior sequences, supporting sequential, parallel, and conditional execution
- **Interruptibility**: Commands can be safely interrupted at any time, ensuring robot state consistency
- **Subsystem Management**: Automatically handles subsystem acquisition and release, preventing resource conflicts
- **State Encapsulation**: Each command encapsulates complete behavioral logic, facilitating testing and reuse

## Example

Let's analyze the structure of the `ChassisTeleop` command to understand the key components of a command:

```java
public class ChassisTeleop extends Command {
  // a. Dependency Declaration

  // b. Constructor
  public ChassisTeleop(
      Chassis chassis, DoubleSupplier fowardSupplier, DoubleSupplier rotationSupplier) {
  }

  // c. Execute Method - Called periodically
  @Override
  public void execute() {
  }

  // d. End Method - Called when the command ends
  @Override
  public void end(boolean interrupted) {
  }

  // e. Returns whether the command is finished
  @Override
  public boolean isFinished() {
  }

  // f. Start Method - Called before command starts
  @Override
  public void initialize() {
  }
}
```

### a. Dependency Declaration

```java
public class ChassisTeleop extends Command {
  private final Chassis chassis;
  private final DoubleSupplier fowardSupplier;
  private final DoubleSupplier rotationSupplier;
}
```

Commands inject required dependencies through the constructor:
- chassis: The subsystem instance to control
- DoubleSupplier: Functional interface that provides input values

### b. Constructor

```java
public class ChassisTeleop extends Command {
  public ChassisTeleop(
      Chassis chassis, DoubleSupplier fowardSupplier, DoubleSupplier rotationSupplier) {
    this.chassis = chassis;
    this.fowardSupplier = fowardSupplier;
    this.rotationSupplier = rotationSupplier;
    addRequirements(chassis); // Key: Declare the subsystems required by this command
    withInterruptBehavior(InterruptionBehavior.kCancelSelf); // Key: Define behavior when command conflicts occur
  }
}
```

The `addRequirements()` method informs the command scheduler that this command requires exclusive access to the `chassis` subsystem. When this command is running, if other commands also require access to this subsystem, the `withInterruptBehavior()` method tells the command scheduler whether to interrupt itself or refuse other commands from running.

### c. Execute Method

```java
public class ChassisTeleop extends Command {
  @Override
  public void execute() {
    // Input Processing
    double forward = 5.0 * Math.abs(fowardSupplier.getAsDouble()) * fowardSupplier.getAsDouble();
    double rotation = 3.0 * Math.abs(rotationSupplier.getAsDouble()) * rotationSupplier.getAsDouble();

    // Control Logic
    if (forward < 0) {
      double leftSpeed = forward + rotation;
      double rightSpeed = forward - rotation;
      chassis.setWheelsVelocities(leftSpeed, rightSpeed);
    } else {
      double leftSpeed = forward - rotation;
      double rightSpeed = forward + rotation;
      chassis.setWheelsVelocities(leftSpeed, rightSpeed);
    }
  }
}
```

The `execute()` method is called every scheduler cycle (approximately 20ms):

- **Input Processing**: Applies non-linear transformations to raw inputs, providing better control experience
- **Control Logic**: Adjusts differential calculations based on forward direction, ensuring intuitive control response

### d. End Method

```java
public class ChassisTeleop extends Command {
  @Override
  public void end(boolean interrupted) {
    chassis.setWheelsVelocities(0, 0);
  }
}
```

The `end()` method is called when the command ends:
- The interrupted parameter indicates whether the command ended normally or was interrupted
- Ensures the subsystem returns to a safe state

### e. Finish Condition

```java
public class ChassisTeleop extends Command {
  @Override
  public boolean isFinished() {
    return false; // Keep running continuously
  }
}
```

For teleop commands, typically returns `false` to keep running continuously until the operator stops or a higher-level command interrupts it.

## Your Turn

Now you need to reference the structure of `ChassisTeleop` to complete the design of the `IntakeTeleop` command. This command should control the intake roller movement and arm angle based on four boolean inputs.

```java
public class IntakeTeleop extends Command {
  private final Intake intake;
  private final BooleanSupplier rollerInjectSupplier;
  private final BooleanSupplier rollerEjectSupplier;
  private final BooleanSupplier armUpSupplier;
  private final BooleanSupplier armDownSupplier;

  public IntakeTeleop(
      Intake intake,
      BooleanSupplier rollerInjectSupplier,
      BooleanSupplier rollerEjectSupplier,
      BooleanSupplier armUpSupplier,
      BooleanSupplier armDownSupplier) {
    this.intake = intake;
    this.rollerInjectSupplier = rollerInjectSupplier;
    this.rollerEjectSupplier = rollerEjectSupplier;
    this.armUpSupplier = armUpSupplier;
    this.armDownSupplier = armDownSupplier;
    addRequirements(intake);
  }

  @Override
  public void execute() {
    // TODO: implement intake teleop control

    // when both buttons are pressed, do nothing
    // when inject button is pressed, intake
    // when eject button is pressed, outtake

    // when both buttons are pressed, do nothing
    // when arm up button is pressed, raise the arm
    // when arm down button is pressed, lower the arm
  }

  @Override
  public void end(boolean interrupted) {
    // TODO: stop the rollers and hold the arm position
  }

  @Override
  public boolean isFinished() {
    return false;
  }
}
```

## Demonstration

Control the robot's left and right wheels forward using the left and right joysticks respectively. The right trigger controls roller intake, the left trigger controls roller outtake. The left shoulder button raises the intake angle, and the right shoulder button lowers the intake angle.

<div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%;">
  <iframe src="https://player.bilibili.com/player.html?bvid=BV1G6HWzfEnF&page=1&high_quality=1&danmaku=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe>
</div>
